<?xml version="1.0" encoding="UTF-8"?>

<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-spaghetti-sshm-filexfer-00"
  ipr="trust200902"
  submissionType="IETF"
  consensus="true">

<front>

  <title>SSH File Transfer Protocol</title>

  <author fullname="Klemens Nanni" initials="K." surname="Nanni" role="editor">
    <organization/>
    <address>
      <postal>
        <street/>
        <code/>
        <city>Moscow</city>
        <country>RU</country>
      </postal>
      <email>kn@openbsd.org</email>
    </address>
  </author>

  <author fullname="Florian Obser" initials="F." surname="Obser" role="editor">
    <organization/>
    <address>
      <postal>
        <street/>
        <code/>
        <city>Den Haag</city>
        <country>NL</country>
      </postal>
      <email>florian@openbsd.org</email>
    </address>
  </author>

  <author fullname="Job Snijders" initials="J." surname="Snijders" role="editor">
    <organization/>
    <address>
      <postal>
        <street/>
        <code/>
        <city>Amsterdam</city>
        <country>NL</country>
      </postal>
      <email>job@sobornost.net</email>
    </address>
  </author>

  <date/>

  <area>SEC</area>
  <workgroup>SSHM</workgroup>

  <abstract>
    <t>
       The SSH File Transfer Protocol provides secure file transfer functionality over any reliable data stream.
       It is the standard file transfer protocol for use with the SSH2 protocol.
       This document describes the file transfer protocol and its interface to the SSH2 protocol suite.
    </t>
  </abstract>

  <note title="Requirements Language">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.
      </t>
  </note>

</front>

<middle>

  <section title="Introduction">
    <t>
       This protocol provides secure file transfer (and more generally file system access) functionality over a reliable data stream, such as a channel in the <xref target="RFC4251">SSH2 protocol</xref>.
    </t>

    <t>
      This protocol is designed so that it could be used to implement a secure remote file system service, as well as a secure file transfer service.
    </t>

    <t>
      This protocol assumes that it runs over a secure channel, and that the server has already authenticated the user at the client end, and that the identity of the client user is externally available to the server implementation.
    </t>

    <t>
      In general, this protocol follows a simple request-response model.
      Each request and response contains a sequence number and multiple requests may be pending simultaneously.
      There are a relatively large number of different request messages, but a small number of possible response messages.
      Each request has one or more response messages that may be returned in result (e.g., a read either returns data or reports error status).
    </t>

    <t>
      The packet format descriptions in this specification follow the notation presented in <xref target="RFC4251"/>.
    </t>

    <t>
      Even though this protocol is described in the context of the SSH2 protocol, this protocol is general and independent of the rest of the SSH2 protocol suite.
      It could be used in a number of different applications, such as secure file transfer over TLS <xref target="RFC8446"/> and transfer of management information in VPN applications.
    </t>

  </section>

  <section title="Use with the SSH Connection Protocol">

    <t>
      When used with the SSH2 Protocol suite, this protocol is intended to be used from the SSH Connection Protocol as a subsystem, as described in <xref target="RFC4254" section="6.5"/>
      The subsystem name used with this protocol is "sftp".
    </t>

  </section>

  <section title="General Packet Format">

    <t>
      All packets transmitted over the secure connection are of the following format:
    </t>

<sourcecode>
uint32             length
byte               type
byte[length - 1]   data payload
</sourcecode>

    <t>
      That is, they are just data preceded by 32-bit length and 8-bit type fields.
      The <tt>length</tt> field contains the length of the data area, and does not include the <tt>length</tt> field itself.
      The format and interpretation of the data area depends on the packet type.
    </t>

    <t>
      All packet descriptions below only specify the packet type and the data that goes into the data field.
      Thus, they should be prefixed by the <tt>length</tt> and <tt>type</tt> fields.
    </t>

    <t>
      The maximum size of a packet is in practice determined by the client (the maximum size of read or write requests that it sends, plus a few bytes of packet overhead).
      All servers SHOULD support packets of at least 34000 bytes (where the packet size refers to the full length, including the header above).
      This should allow for reads and writes of at most 32768 bytes.
    </t>

    <t>
      There is no limit on the number of outstanding (non-acknowledged) requests that the client may send to the server.
      In practice this is limited by the buffering available on the data stream and the queuing performed by the server.
      If the server's queues are full, it should not read any more data from the stream, and flow control will prevent the client from sending more requests.
      Note, however, that while there is no restriction on the protocol level, the client's API may provide a limit in order to prevent infinite queuing of outgoing requests at the client.
    </t>

    <t>
      The following values are defined for packet types.
    </t>

<sourcecode type="c">
#define SSH_FXP_INIT                1
#define SSH_FXP_VERSION             2
#define SSH_FXP_OPEN                3
#define SSH_FXP_CLOSE               4
#define SSH_FXP_READ                5
#define SSH_FXP_WRITE               6
#define SSH_FXP_LSTAT               7
#define SSH_FXP_FSTAT               8
#define SSH_FXP_SETSTAT             9
#define SSH_FXP_FSETSTAT           10
#define SSH_FXP_OPENDIR            11
#define SSH_FXP_READDIR            12
#define SSH_FXP_REMOVE             13
#define SSH_FXP_MKDIR              14
#define SSH_FXP_RMDIR              15
#define SSH_FXP_REALPATH           16
#define SSH_FXP_STAT               17
#define SSH_FXP_RENAME             18
#define SSH_FXP_READLINK           19
#define SSH_FXP_SYMLINK            20
#define SSH_FXP_STATUS            101
#define SSH_FXP_HANDLE            102
#define SSH_FXP_DATA              103
#define SSH_FXP_NAME              104
#define SSH_FXP_ATTRS             105
#define SSH_FXP_EXTENDED          200
#define SSH_FXP_EXTENDED_REPLY    201
</sourcecode>

    <t>
      Additional packet types should only be defined if the protocol version number (see <xref target="init"/>) is incremented, and their use MUST be negotiated using the version number.
      However, the SSH_FXP_EXTENDED and SSH_FXP_EXTENDED_REPLY packets can be used to implement vendor-specific extensions.
      See <xref target="vse"/> for more details.
    </t>

  </section>

  <section title="Protocol Initialization" anchor="init">

    <t>
      When the file transfer protocol starts, it first sends a <tt>SSH_FXP_INIT</tt> (including its version number) packet to the server.
      The server responds with a <tt>SSH_FXP_VERSION</tt> packet, supplying the lowest of its own and the client's version number.
      This is the negotiated protocol version number that both parties MUST adhere to.
    </t>

    <t>
      The <tt>SSH_FXP_INIT</tt> packet (from client to server) has the following data:
    </t>

<sourcecode>
<![CDATA[
uint32 version
<extension data>
]]>
</sourcecode>

    <t>
      The <tt>SSH_FXP_VERSION</tt> packet (from server to client) has the following data:
    </t>

<sourcecode>
<![CDATA[
uint32 version
<extension data>
]]>
</sourcecode>

    <t>
      The version number of the protocol specified in this document is 3.
      The version number MUST be incremented for each incompatible revision of this protocol.
    </t>

    <t>
      The extension data in the above packets MAY be empty, or MAY be a sequence of
    </t>

<sourcecode>
string extension_name
string extension_data
</sourcecode>

    <t>
      pairs (both strings MUST always be present if one is, but the <tt>extension_data</tt> string MAY be of zero length).
      If present, these strings indicate extensions to the baseline protocol.
      The <tt>extension_name</tt> field(s) identify the name of the extension.
      The name SHOULD be of the form "name@domain", where the domain is the DNS domain name of the organization defining the extension.
      Additional names that are not of this format may be defined later by the IETF.
      Implementations MUST silently ignore any extensions whose name they do not recognize.
    </t>

  </section>

  <section title="File Attributes" anchor="fa">

    <t>
      A new compound data type is defined for encoding file attributes.
      It is basically just a combination of elementary types, but is defined once because of the non-trivial description of the fields and to ensure maintainability.
    </t>

    <t>
      The same encoding is used both when returning file attributes from the server and when sending file attributes to the server.
      When sending it to the server, the flags field specifies which attributes are included, and the server will use default values for the remaining attributes (or will not modify the values of remaining attributes).
      When receiving attributes from the server, the flags specify which attributes are included in the returned data.
      The server normally returns all attributes it knows about.
    </t>

<sourcecode>
uint32   flags
uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE
uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID
uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID
uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS
uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME
uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME
uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED
string   extended_type
string   extended_data
...      more extended data (extended_type - extended_data pairs),
         so that number of pairs equals extended_count
</sourcecode>

    <t>
      The <tt>flags</tt> specify which of the fields are present.
      Those fields for which the corresponding flag is not set are not present (not included in the packet).
      New flags can only be added by incrementing the protocol version number (or by using the extension mechanism described below).
    </t>

    <t>
      The <tt>size</tt> field specifies the size of the file in bytes.
    </t>

    <t>
      The <tt>uid</tt> and <tt>gid</tt> fields contain numeric Unix-like user and group identifiers, respectively.
    </t>

    <t>
      The <tt>permissions</tt> field contains a bit mask of file permissions as defined by <xref target="POSIX"/>.
    </t>

    <t>
      The <tt>atime</tt> and <tt>mtime</tt> contain the access and modification times of the files, respectively.
      They are represented as seconds from Jan 1, 1970 in UTC.
    </t>

    <t>
      The <tt>SSH_FILEXFER_ATTR_EXTENDED</tt> flag provides a general extension mechanism for vendor-specific extensions.
      If the flag is specified, then the <tt>extended_count</tt> field is present.
      It specifies the number of <tt>extended_type-extended_data</tt> pairs that follow.
      Each of these pairs specifies an extended attribute.
      For each of the attributes, the <tt>extended_type</tt> field SHOULD be a string of the format "name@domain", where "domain" is a valid, registered domain name and "name" identifies the method.
      The IETF may later standardize certain names that deviate from this format (e.g., that do not contain the "@" sign).
      The interpretation of <tt>extended_data</tt> depends on the type.
      Implementations SHOULD ignore extended data fields that they do not understand.
    </t>

    <t>
      Additional fields can be added to the attributes by either defining additional bits to the flags field to indicate their presence, or by defining extended attributes for them.
      The extended attributes mechanism is recommended for most purposes; additional flags bits should only be defined by an IETF standards action that also increments the protocol version number.
      The use of such new fields MUST be negotiated by the version number in the protocol exchange.
      It is a protocol error if a packet with unsupported flags bits is received.
    </t>

    <t>
      The flags bits are defined to have the following values:
    </t>

<sourcecode>
#define SSH_FILEXFER_ATTR_SIZE          0x00000001
#define SSH_FILEXFER_ATTR_UIDGID        0x00000002
#define SSH_FILEXFER_ATTR_PERMISSIONS   0x00000004
#define SSH_FILEXFER_ATTR_ACMODTIME     0x00000008
#define SSH_FILEXFER_ATTR_EXTENDED      0x80000000
</sourcecode>


  </section>

  <section title="Requests From the Client to the Server">

    <t>
      Requests from the client to the server represent the various file system operations.
      Each request begins with an <tt>id</tt> field, which is a 32-bit identifier identifying the request (selected by the client).
      The same identifier will be returned in the response to the request.
      One possible implementation of it is a monotonically increasing request sequence number (modulo 2^32).
    </t>

    <t>
      Many operations in the protocol operate on open files.
      The <tt>SSH_FXP_OPEN</tt> request can return a file handle (which is an opaque variable-length string) which may be used to access the file later (e.g. in a read operation).
      The client MUST NOT send requests to the server with bogus or closed handles.
      However, the server MUST perform adequate checks on the handle in order to avoid security risks due to fabricated handles.
    </t>

    <t>
      This design allows either stateful and stateless server implementation, as well as an implementation which caches state between requests but may also flush it.
      The contents of the file handle string are entirely up to the server and its design.
      The client MUST NOT modify or attempt to interpret the file handle strings.
    </t>

    <t>
     The file handle strings MUST NOT be longer than 256 bytes.
    </t>

    <section title="Request Synchronization and Reordering">

      <t>
        The server MUST process requests relating to the same file in the order in which they are received.
        In other words, if an application submits multiple requests to the server, the results in the responses will be the same as if it had sent the requests one at a time and waited for the response in each case.
        For example, the server may process non-overlapping read/write requests to the same file in parallel, but overlapping reads and writes cannot be reordered or parallelized.
        However, there are no ordering restrictions on the server for processing requests from two different file transfer connections.
        The server may interleave and parallelize them at will.
      </t>

      <t>
        There are no restrictions on the order in which responses to outstanding requests are delivered to the client, except that the server must ensure fairness.
	No request will be indefinitely delayed even if the client is sending other requests so that there are multiple outstanding requests all the time.
      </t>

    </section>

    <section title="File Names" anchor="fn">

      <t>
        This protocol represents file names as strings.
        File names are assumed to use the slash ('/') character as a directory separator.
      </t>

      <t>
        File names starting with a slash ('/') are "absolute", and are relative to the root of the file system.
        Names starting with any other character are relative to the user's default directory (home directory).
        Note that identifying the user is assumed to take place outside of this protocol.
      </t>

      <t>
        Servers SHOULD interpret a path name component ".." as referring to the parent directory, and "." as referring to the current directory.
	Care must be taken that clients cannot use ".." to escape file system access limitations set by the server.
      </t>

      <t>
        An empty path name is valid, and it refers to the user's default directory (usually the user's home directory).
      </t>

      <t>
        Clients can splice path name components returned by SSH_FXP_READDIR together using a slash ('/') as the separator.
      </t>

      <t>
	Otherwise, no syntax is defined for file names by this specification.
      </t>

    </section>

    <section title="Opening, Creating, and Closing Files">

      <t>
        Files are opened and created using the SSH_FXP_OPEN message, whose data part is as follows:
      </t>

<sourcecode>
uint32        id
string        filename
uint32        pflags
ATTRS         attrs
</sourcecode>

      <t>
        The <tt>id</tt> field is the request identifier as for all requests.
      </t>
      <t>
        The <tt>filename</tt> field specifies the file name.
        See <xref target="fn"/> for more information.
      </t>

      <t>
        The <tt>pflags</tt> field is a bitmask.
        The following bits have been defined.
      </t>

<sourcecode>
#define SSH_FXF_READ            0x00000001
#define SSH_FXF_WRITE           0x00000002
#define SSH_FXF_APPEND          0x00000004
#define SSH_FXF_CREAT           0x00000008
#define SSH_FXF_TRUNC           0x00000010
#define SSH_FXF_EXCL            0x00000020
</sourcecode>

      <t>
        These have the following meanings:
      </t>

      <dl>
        <dt>SSH_FXF_READ</dt>
        <dd>
          Open the file for reading.
        </dd>

        <dt>SSH_FXF_WRITE</dt>
        <dd>
          Open the file for writing.
          If both this and SSH_FXF_READ are specified, the file is opened for both reading and writing.
        </dd>

        <dt>SSH_FXF_APPEND</dt>
        <dd>
          Force all writes to append data at the end of the file.
        </dd>

        <dt>SSH_FXF_CREAT</dt>
        <dd>
	  Create the file if it does not already exist.
        </dd>

        <dt>SSH_FXF_TRUNC</dt>
        <dd>
	  Truncate an existing file to zero length.
        </dd>

        <dt>SSH_FXF_EXCL</dt>
        <dd>
          Causes the request to fail if the named file already exists.
          <tt>SSH_FXF_CREAT</tt> MUST also be specified if this flag is used.
        </dd>
      </dl>

      <t>
        The <tt>attrs</tt> field specifies the initial attributes for the file.
        Default values will be used for those attributes that are not specified.
        See <xref target="fa"/> for more information.
      </t>

      <t>
        Regardless the server operating system, the file will always be opened in "binary" mode (i.e., no translations between different character sets and newline encodings).
	If the operation is successful the server MUST respond with <tt>SSH_FXP_HANDLE</tt>.
	If the operation failed the server MUST respond with <tt>SSH_FXP_STATUS</tt>.
      </t>

      <t>
        A file is closed by using the <tt>SSH_FXP_CLOSE</tt> request.
        Its data field has the following format:
      </t>

<sourcecode>
uint32     id
string     handle
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, and <tt>handle</tt> is a handle previously returned in the response to <tt>SSH_FXP_OPEN</tt> or <tt>SSH_FXP_OPENDIR</tt>.
        The handle becomes invalid immediately after this request has been sent.
      </t>

      <t>
        The server MUST respond with a  <tt>SSH_FXP_STATUS</tt> message.
        On some server platforms a close can fail.
      </t>

    </section>

    <section title="Reading and Writing" anchor="rw">

      <t>
        Once a file has been opened, it can be read using the <tt>SSH_FXP_READ</tt> message, which has the following format:
      </t>

<sourcecode>
uint32     id
string     handle
uint64     offset
uint32     len
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, <tt>handle</tt> is an open file handle returned by SSH_FXP_OPEN, <tt>offset</tt> is the offset (in bytes) relative to the beginning of the file from where to start reading, and <tt>len</tt> is the maximum number of bytes to read.
      </t>

      <t>
        In response to this request, the server MUST read as many bytes as it can from the file (up to <tt>len</tt>), and return them in a <tt>SSH_FXP_DATA</tt> message.
        If an error occurs or EOF is encountered before reading any data, the server MUST respond with <tt>SSH_FXP_STATUS</tt>.
      </t>

      <t>
	The client SHOULD then close the handle using the <tt>SSH_FXP_CLOSE</tt> request when it is done.
      </t>

      <t>
        Writing to a file is achieved using the <tt>SSH_FXP_WRITE</tt> message, which has the following format:
      </t>

<sourcecode>
uint32     id
string     handle
uint64     offset
string     data
</sourcecode>

      <t>
        where <tt>id</tt> is a request identifier, <tt>handle</tt> is a file handle returned by <tt>SSH_FXP_OPEN</tt>, <tt>offset</tt> is the offset (in bytes) from the beginning of the file where to start writing, and <tt>data</tt> is the data to be written.
      </t>

      <t>
        The write will extend the file if writing beyond the end of the file.
        It is legal to write way beyond the end of the file; the semantics are to write zeroes from the end of the file to the specified offset and then the data.
        On most operating systems, such writes do not allocate disk space but instead leave "holes" in the file.
      </t>

      <t>
        The server MUST respond to a write request with a <tt>SSH_FXP_STATUS</tt> message.
      </t>

      <t>
	The client SHOULD then close the handle using the <tt>SSH_FXP_CLOSE</tt> request when it is done.
      </t>

    </section>

    <section title="Removing and Renaming Files" anchor="rrf">

      <t>
        Files can be removed using the <tt>SSH_FXP_REMOVE</tt> message.
        It has the following format:
      </t>

<sourcecode>
uint32     id
string     filename
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier and <tt>filename</tt> is the name of the file to be removed.
        See <xref target="fn"/> for more information.
        This request cannot be used to remove directories.
      </t>

      <t>
        The server MUST respond to this request with a <tt>SSH_FXP_STATUS</tt> message.
      </t>

      <t>
        Files (and directories) can be renamed using the <tt>SSH_FXP_RENAME</tt> message.
        Its data is as follows:
      </t>

<sourcecode>
uint32     id
string     oldpath
string     newpath
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, <tt>oldpath</tt> is the name of an existing file or directory, and <tt>newpath</tt> is the new name for the file or directory.
        It is an error if there already exists a file with the name specified by <tt>newpath</tt>.
        The server may also fail rename requests in other situations, for example if <tt>oldpath</tt> and <tt>newpath</tt> point to different file systems on the server.
      </t>

      <t>
        The server MUST respond to this request with a <tt>SSH_FXP_STATUS</tt> message.
      </t>


    </section>

    <section title="Creating and Deleting Directories" anchor="cdd">

      <t>
        New directories can be created using the <tt>SSH_FXP_MKDIR</tt> request.
        It has the following format:
      </t>

<sourcecode>
uint32     id
string     path
ATTRS      attrs
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, <tt>path</tt> and <tt>attrs</tt> specifies the modifications to be made to its attributes.
        See <xref target="fn"/> for more information on file names.
        Attributes are discussed in more detail in <xref target="fa"/>.
        <tt>path</tt> specifies the directory to be created.
        The server MUST respond to this request with a <tt>SSH_FXP_STATUS</tt> message.
        The server MUST return an error if a file or directory with the specified path already exists.
      </t>

      <t>
        Directories can be removed using the <tt>SSH_FXP_RMDIR</tt> request, which has the following format:
      </t>

<sourcecode>
uint32     id
string     path
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, and <tt>path</tt> specifies the directory to be removed.
        See <xref target="fn"/> for more information on file names.
        The server MUST respond to this request with a <tt>SSH_FXP_STATUS</tt> message.
        The server MUST return an error if no directory with the specified path exists, or if the specified directory is not empty, or if the path specified a file system object other than a directory.
      </t>

    </section>

    <section title="Scanning Directories" anchor="sd">

      <t>
        The files in a directory can be listed using the <tt>SSH_FXP_OPENDIR</tt> and <tt>SSH_FXP_READDIR</tt> requests.
        Each <tt>SSH_FXP_READDIR</tt> request returns one or more file names with full file attributes for each file.
        The client should call <tt>SSH_FXP_READDIR</tt> repeatedly until it has found the file it is looking for or until the server responds with a <tt>SSH_FXP_STATUS</tt> message indicating an error (normally <tt>SSH_FX_EOF</tt> if there are no more files in the directory).
        The client SHOULD then close the handle using the <tt>SSH_FXP_CLOSE</tt> request.
      </t>

      <t>
        The <tt>SSH_FXP_OPENDIR</tt> request opens a directory for reading.
        It has the following format:
      </t>

<sourcecode>
uint32     id
string     path
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier and <tt>path</tt> is the path name of the directory to be listed (without any trailing slash).
        See <xref target="fn"/> for more information on file names.
        The server MUST respond to this request with either a <tt>SSH_FXP_HANDLE</tt> or a <tt>SSH_FXP_STATUS</tt> message.
	The server MUST return an error if the path does not specify a directory or if the directory is not readable.
      </t>

      <t>
        Once the directory has been successfully opened, files (and directories) contained in it can be listed using <tt>SSH_FXP_READDIR</tt> requests.
        These are of the following format:
      </t>

<sourcecode>
uint32     id
string     handle
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, and <tt>handle</tt> is a handle returned by <tt>SSH_FXP_OPENDIR</tt>.
        (It is a protocol error to attempt to use an ordinary file handle returned by <tt>SSH_FXP_OPEN</tt>.)
      </t>

      <t>
        The server MUST respond to this request with either a <tt>SSH_FXP_NAME</tt> or a <tt>SSH_FXP_STATUS</tt> message.
        One or more names MAY be returned at a time.
        Full status information is returned for each name in order to speed up typical directory listings.
      </t>

      <t>
        When the client no longer wishes to read more names from the directory, it SHOULD call <tt>SSH_FXP_CLOSE</tt> for the handle.
        The handle SHOULD be closed regardless of whether an error has occurred or not.
      </t>

    </section>

    <section title="Retrieving File Attributes" anchor="rfa">

      <t>
        Very often, file attributes are automatically returned by <tt>SSH_FXP_READDIR</tt>.
        However, sometimes there is need to specifically retrieve the attributes for a named file.
        This can be done using the <tt>SSH_FXP_STAT</tt>, <tt>SSH_FXP_LSTAT</tt> and <tt>SSH_FXP_FSTAT</tt> requests.
      </t>

      <t>
        <tt>SSH_FXP_STAT</tt> and <tt>SSH_FXP_LSTAT</tt> only differ in that <tt>SSH_FXP_STAT</tt> follows symbolic links on the server, whereas <tt>SSH_FXP_LSTAT</tt> does not follow symbolic links.
        Both have the same format:
      </t>

<sourcecode>
uint32     id
string     path
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, and <tt>path</tt> specifies the file system object for which status is to be returned.
        The server MUST respond to this request with either <tt>SSH_FXP_ATTRS</tt> or <tt>SSH_FXP_STATUS</tt>.
      </t>

      <t>
        <tt>SSH_FXP_FSTAT</tt> differs from the others in that it returns status information for an open file (identified by the file handle).
        Its format is as follows:
      </t>

<sourcecode>
uint32     id
string     handle
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier and <tt>handle</tt> is a file handle returned by <tt>SSH_FXP_OPEN</tt>.
        The server MUST respond to this request with <tt>SSH_FXP_ATTRS</tt> or <tt>SSH_FXP_STATUS</tt>.
      </t>

    </section>

    <section title="Setting File Attributes" anchor="sfa">

      <t>
        File attributes may be modified using the <tt>SSH_FXP_SETSTAT</tt> and <tt>SSH_FXP_FSETSTAT</tt> requests.
        These requests are used for operations such as changing the ownership, permissions or access times, as well as for truncating a file.
      </t>

      <t>
        The <tt>SSH_FXP_SETSTAT</tt> request is of the following format:
      </t>

<sourcecode>
uint32     id
string     path
ATTRS      attrs
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, <tt>path</tt> specifies the file system object (e.g. file or directory) whose attributes are to be modified, and <tt>attrs</tt> specifies the modifications to be made to its attributes.
        Attributes are discussed in more detail in <xref target="fa"/>.
      </t>

      <t>
        The server MUST respond to this request with a <tt>SSH_FXP_STATUS</tt> message.
        The server MUST return an error if the specified file system object does not exist or the user does not have sufficient rights to modify the specified attributes.
      </t>

      <t>
        The <tt>SSH_FXP_FSETSTAT</tt> request modifies the attributes of a file which is already open.
        It has the following format:
      </t>

<sourcecode>
uint32     id
string     handle
ATTRS      attrs
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, <tt>handle</tt> (MUST be returned by <tt>SSH_FXP_OPEN</tt>) identifies the file whose attributes are to be modified, and <tt>attrs</tt> specifies the modifications to be made to its attributes.
        Attributes are discussed in more detail in <xref target="fa"/>.
        The server MUST respond to this request with <tt>SSH_FXP_STATUS</tt>.
	The server MUST return an error if the user does not have sufficient rights to modify the specified attributes.
      </t>

    </section>

    <section title="Dealing with Symbolic links" anchor="sl">

      <t>
        The <tt>SSH_FXP_READLINK</tt> request may be used to read the target of a symbolic link.
        It would have a data part as follows:
      </t>

<sourcecode>
uint32     id
string     path
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier and <tt>path</tt> specifies the path name of the symlink to be read.
      </t>

      <t>
	If an error occurs, the server MUST respond with <tt>SSH_FXP_STATUS</tt>.
        Otherwise, the server MUST respond with a <tt>SSH_FXP_NAME</tt> packet containing only one name and a dummy attributes value.
        The name in the returned packet contains the target of the link.
      </t>

      <t>
        The <tt>SSH_FXP_SYMLINK</tt> request will create a symbolic link on the server.
        It is of the following format:
      </t>

<sourcecode>
uint32     id
string     linkpath
string     targetpath
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier, <tt>linkpath</tt> specifies the path name of the symlink to be created and <tt>targetpath</tt> specifies the target of the symlink.
        The server MUST respond with a <tt>SSH_FXP_STATUS</tt> indicating either success (<tt>SSH_FX_OK</tt>) or an error condition.
      </t>

    </section>

    <section title="Canonicalizing the Server-Side Path Name" anchor="csspn">

      <t>
        The <tt>SSH_FXP_REALPATH</tt> request can be used to have the server canonicalize any given path name to an absolute path.
        This is useful for converting path names containing ".." components or relative pathnames without a leading slash into absolute paths.
        The format of the request is as follows:
      </t>

<sourcecode>
uint32     id
string     path
</sourcecode>

      <t>
        where <tt>id</tt> is the request identifier and <tt>path</tt> specifies the path name to be canonicalized.
	If an error occurs, the server MUST respond with <tt>SSH_FXP_STATUS</tt>.
        Otherwise, the server MUST respond with a <tt>SSH_FXP_NAME</tt> packet containing only one name and a dummy attributes value.
        The name is the returned packet will be in canonical form.
      </t>

    </section>

  </section>

  <section title="Responses from the Server to the Client" anchor="rftsttc">

    <t>
      The server responds to the client using one of a few response packets.
      All requests MUST return a <tt>SSH_FXP_STATUS</tt> response upon failure.
      When the operation is successful, any of the responses may be returned (depending on the operation).
      If no data needs to be returned to the client, the <tt>SSH_FXP_STATUS</tt> response with <tt>SSH_FX_OK</tt> status MUST be send.
      Otherwise, the <tt>SSH_FXP_HANDLE</tt> message is used to return a file handle (for <tt>SSH_FXP_OPEN</tt> and <tt>SSH_FXP_OPENDIR</tt> requests), <tt>SSH_FXP_DATA</tt> is used to return data from <tt>SSH_FXP_READ</tt>, <tt>SSH_FXP_NAME</tt> is used to return one or more file names from a <tt>SSH_FXP_READDIR</tt> or <tt>SSH_FXP_REALPATH</tt> request, and <tt>SSH_FXP_ATTRS</tt> is used to return file attributes from <tt>SSH_FXP_STAT</tt>, <tt>SSH_FXP_LSTAT</tt>, and <tt>SSH_FXP_FSTAT</tt> requests.
    </t>

    <t>
      Exactly one response will be returned for each request.
      Each response packet MUST contain a request identifier which MUST be used to match each response with the corresponding request.
      Note that it is legal to have several requests outstanding simultaneously, and the server MAY send responses to them in a different order from the order in which the requests were sent (the result of their execution, however, is MUST be as if they had been processed one at a time in the order in which the requests were sent).
    </t>

    <t>
      Response packets are of the same general format as request packets.
      Each response packet begins with the request identifier.
    </t>

    <t>
      The format of the data portion of the <tt>SSH_FXP_STATUS</tt> response is as follows:
    </t>

<sourcecode>
uint32     id
uint32     error/status code
string     error message (ISO-10646 UTF-8 RFC 2279)
string     language tag (as defined in RFC 1766)
</sourcecode>

    <t>
      where <tt>id</tt> is the request identifier, and <tt>error/status code</tt> indicates the result of the requested operation.
      The value <tt>SSH_FX_OK</tt> indicates success, and all other values indicate failure.
    </t>

    <t>
      Currently, the following values are defined (other values may be defined by future versions of this protocol):
    </t>

<sourcecode>
#define SSH_FX_OK                            0
#define SSH_FX_EOF                           1
#define SSH_FX_NO_SUCH_FILE                  2
#define SSH_FX_PERMISSION_DENIED             3
#define SSH_FX_FAILURE                       4
#define SSH_FX_BAD_MESSAGE                   5
#define SSH_FX_NO_CONNECTION                 6
#define SSH_FX_CONNECTION_LOST               7
#define SSH_FX_OP_UNSUPPORTED                8
</sourcecode>

    <dl>

      <dt>SSH_FX_OK</dt>
      <dd>
        Indicates successful completion of the operation.
      </dd>

      <dt>SSH_FX_EOF</dt>
      <dd>
        Indicates end-of-file condition; for <tt>SSH_FX_READ</tt> it MUST be returned when no more data is available in the file, and for <tt>SSH_FX_READDIR</tt> it MUST be returned when no more files are contained in the directory.
      </dd>

      <dt>SSH_FX_NO_SUCH_FILE</dt>
      <dd>
        MUST be returned when a reference is made to a file which should exist but doesn't.
      </dd>

      <dt>SSH_FX_PERMISSION_DENIED</dt>
      <dd>
        MUST be returned when the authenticated user does not have sufficient permissions to perform the operation.
      </dd>

      <dt>SSH_FX_FAILURE</dt>
      <dd>
        Is a generic catch-all error message; it SHOULD be returned if an error occurs for which there is no more specific error code defined.
      </dd>

      <dt>SSH_FX_BAD_MESSAGE</dt>
      <dd>
        MAY be returned if a badly formatted packet or protocol incompatibility is detected.
      </dd>

      <dt>SSH_FX_NO_CONNECTION</dt>
      <dd>
        Is a pseudo-error which indicates that the client has no connection to the server (it can only be generated locally by the client, and MUST NOT be returned by servers).
      </dd>

      <dt>SSH_FX_CONNECTION_LOST</dt>
      <dd>
        Is a pseudo-error which indicates that the connection to the server has been lost (it can only be generated locally by the client, and MUST NOT be returned by servers).
      </dd>

      <dt>SSH_FX_OP_UNSUPPORTED</dt>
      <dd>
        indicates that an attempt was made to perform an operation which is not supported for the server (it may be generated locally by the client if e.g. the version number exchange indicates that a required feature is not supported by the server, or it MAY be returned by the server if the server does not implement an operation).
      </dd>

    </dl>

    <t>
      The SSH_FXP_HANDLE response has the following format:
    </t>

<sourcecode>
uint32     id
string     handle
</sourcecode>

    <t>
      where <tt>id</tt> is the request identifier, and <tt>handle</tt> is an arbitrary string that identifies an open file or directory on the server.
      The handle is opaque to the client; the client MUST NOT attempt to interpret or modify it in any way.
      The length of the handle string MUST NOT exceed 256 data bytes.
    </t>

    <t>
      The SSH_FXP_DATA response has the following format:
    </t>

<sourcecode>
uint32     id
string     data
</sourcecode>

    <t>
      where <tt>id</tt> is the request identifier, and <tt>data</tt> is an arbitrary byte string containing the requested data.
      The data string MAY be at most the number of bytes requested in a <tt>SSH_FXP_READ</tt> request, but MAY also be shorter if end of file is reached or if the read is from something other than a regular file.
    </t>

    <t>
      The SSH_FXP_NAME response has the following format:
    </t>

<sourcecode>
uint32     id
uint32     count
repeats count times:
    string     filename
    string     longname
    ATTRS      attrs
</sourcecode>

    <t>
      where <tt>id</tt> is the request identifier, <tt>count</tt> is the number of names returned in this response, and the remaining fields repeat count' times (so that all three fields are first included for the first file, then for the second file, etc).
      In the repeated part, <tt>filename</tt> is a file name being returned (for <tt>SSH_FXP_READDIR</tt>, it will be a relative name within the directory, without any path components; for <tt>SSH_FXP_REALPATH</tt> it will be an absolute path name), <tt>longname</tt> is an expanded format for the file name, similar to what is returned by <tt>ls -l</tt> on Unix-like systems, and <tt>attrs</tt> is the attributes of the file as described in <xref target="fa"/>.
    </t>

    <t>
      The format of the <tt>longname</tt> field is unspecified by this protocol.
      It MUST be suitable for use in the output of a directory listing command (in fact, the recommended operation for a directory listing command is to simply display this data).
      However, clients SHOULD NOT attempt to parse the longname field for file attributes; they SHOULD use the <tt>attrs</tt> field instead.
    </t>

    <t>
      The recommended format for the longname field is as follows:
    </t>

<sourcecode>
-rwxr-xr-x   1 mjos     staff      348911 Mar 25 14:29 t-filexfer
1234567890 123 12345678 12345678 12345678 123456789012
</sourcecode>

    <t>
      Here, the first line is sample output, and the second field indicates widths of the various fields.
      Fields are separated by spaces.
      The first field lists file permissions for user, group, and others; the second field is link count; the third field is the name of the user who owns the file; the fourth field is the name of the group that owns the file; the fifth field is the size of the file in bytes; the sixth field (which actually may contain spaces, but is fixed to 12 characters) is the file modification time, and the seventh field is the file name.
      Each field is specified to be a minimum of certain number of character positions (indicated by the second line above), but may also be longer if the data does not fit in the specified length.
    </t>

    <t>
      The SSH_FXP_ATTRS response has the following format:
    </t>

<sourcecode>
uint32     id
ATTRS      attrs
</sourcecode>

    <t>
      where <tt>id</tt> is the request identifier, and <tt>attrs</tt> is the returned file attributes as described in <xref target="fa"/>.
    </t>

  </section>

  <section title="Vendor-Specific Extensions" anchor="vse">

    <t>
      The <tt>SSH_FXP_EXTENDED</tt> request provides a generic extension mechanism for adding vendor-specific commands.
      The request has the following format:
    </t>

<sourcecode>
uint32     id
string     extended-request
... any request-specific data ...
</sourcecode>

    <t>
      where <tt>id</tt> is the request identifier, and <tt>extended-request</tt> SHOULD be a string of the format "name@domain", where domain is an internet domain name of the vendor defining the request.
      The rest of the request is completely vendor-specific, and servers SHOULD only attempt to interpret it if they recognize the extended-request' name.
    </t>

    <t>
      The server MAY respond to such requests using any of the response packets defined in <xref target="rftsttc"/>.
      The server MAY alternatively respond with a <tt>SSH_FXP_EXTENDED_REPLY</tt> packet, as defined below.
      If the server does not recognize the <tt>extended-request</tt> name, then the server MUST respond with <tt>SSH_FXP_STATUS</tt> with <tt>error/status</tt> set to <tt>SSH_FX_OP_UNSUPPORTED</tt>.
    </t>

    <t>
      The <tt>SSH_FXP_EXTENDED_REPLY</tt> packet can be used to carry arbitrary extension-specific data from the server to the client.
      It is of the following format:
    </t>

<sourcecode>
uint32     id
... any request-specific data ...
</sourcecode>

  </section>

  <section title="Security Considerations">

    <t>
      This protocol assumes that it is run over a secure channel and that the endpoints of the channel have been authenticated.
      Thus, this protocol assumes that it is externally protected from network-level attacks.
    </t>

    <t>
      This protocol provides file system access to arbitrary files on the server (only constrained by the server implementation).
      It is the responsibility of the server implementation to enforce any access controls that may be required to limit the access allowed for any particular user (the user being authenticated externally to this protocol, typically using the SSH User Authentication Protocol <xref target="RFC4252"/>.
    </t>

    <t>
      Care must be taken in the server implementation to check the validity of received file handle strings.
      The server should not rely on them directly; it MUST check the validity of each handle before relying on it.
    </t>

  </section>

  <section title="IANA Considerations">
    <t>
      This document has no IANA actions.
    </t>
  </section>

  <section title="Contributors">

    <t>
      The following people contributed to the original version of this document:
    </t>

    <figure>
<artwork>
   Tatu Ylonen
   Email: ylo@clausal.com

   Sami Lehtinen
   EMail: sjl@iki.fi
</artwork>
    </figure>

  </section>

  <section title="Open Questions">

    <t>
      This section is to be removed before publication.
    </t>

    <section title="SSH_FXP_SYMLINK">

      <t>
	The <tt>SSH_FXP_SYMLINK</tt> in <xref target="sl"/> is specified as
      </t>

<sourcecode>
uint32     id
string     linkpath
string     targetpath
</sourcecode>

      <t>
	The wildly deployed OpenSSH implementation deviates from that
<sourcecode>
https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.bin/ssh/PROTOCOL
</sourcecode>
      </t>

      <blockquote>
	4.1. sftp: Reversal of arguments to SSH_FXP_SYMLINK

	When OpenSSH's sftp-server was implemented, the order of the arguments
	to the SSH_FXP_SYMLINK method was inadvertently reversed. Unfortunately,
	the reversal was not noticed until the server was widely deployed. Since
	fixing this to follow the specification would cause incompatibility, the
	current order was retained. For correct operation, clients should send
	SSH_FXP_SYMLINK as follows:
	<sourcecode>
          uint32     id
          string     targetpath
          string     linkpath
	</sourcecode>
      </blockquote>

      <t>
	Should we instead fix the draft?
	AsyncSSH implements both versions and matches on the client or server version string:

<sourcecode>
https://github.com/ronf/asyncssh/blob/76c14dd0034d33773e2f50f91d167bfd22c3e021/asyncssh/sftp.py#L3182

https://github.com/ronf/asyncssh/blob/76c14dd0034d33773e2f50f91d167bfd22c3e021/asyncssh/sftp.py#L2854
</sourcecode>
      </t>

    </section>

    <section title="SSH_FX_NO_CONNECTION / SSH_FX_CONNECTION_LOST">

      <t>
	<tt>SSH_FX_NO_CONNECTION</tt> and <tt>SSH_FX_CONNECTION_LOST</tt> are specified in <xref target="rftsttc" />.
	They are "pseudo-error" codes and MUST NOT be returned by the server.
	Can we remove them, they do not serve any purpose.
	Or is this too confusing because it creates a gap in the status / error code list?
      </t>
    </section>

    <section title="IANA registry">

      <t>
	While we have the hood open, do we want to direct the IANA to create a registry for extensions?
      </t>

    </section>

  </section>

</middle>

<back>

  <!-- https://authors.ietf.org/en/references-in-rfcxml -->

  <references title="Normative References">

    <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
    <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4251.xml"/>
    <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4252.xml"/>
    <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4254.xml"/>
    <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
    <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>

    <reference anchor="POSIX" target="https://publications.opengroup.org/standards/unix/c243" quoteTitle="true" derivedAnchor="POSIX">
      <front>
        <title>Base Specifications</title>
        <author>
          <organization showOnFrontPage="true">IEEE and The Open Group</organization>
        </author>
        <date year="2024"/>
      </front>
      <refcontent>Issue 8</refcontent>
      <seriesInfo name="DOI" value="10.1109/IEEESTD.2024.10555529"/>
    </reference>

  </references>

</back>

</rfc>
